//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

         
// USER INCLUDES			
#include <SI_EFM8BB3_Register_Enums.h>
int hourprime1;
int minprime1;
int secprime1;
int hourprime2;
int minprime2;
int secprime2;
int hourprime3;
int minprime3;
int secprime3;
int hour;
int min;
int sec;
int on;

void Timer3_Init(int counts)
{
   TMR3CN0  = 0x00;                    // Resets Timer 3, sets to 16 bit mode
   CKCON0  |= 0x40;                    // Use system clock
   TMR3RL   = -counts;                 // Initial reload value
   sec++;
   TMR3    = 0xffff;                   // Sets timer to reload automatically
   EIE1   |= 0x80;                     // Enable Timer 3 interrupts
   TMR3CN0 = 0x04;                     // Start Timer 3
}

//-----------------------------------------------------------------------------
// Global Constants
//-----------------------------------------------------------------------------
SI_SBIT(LED0, SFR_P1, 4);                  // P1.4 LED0
SI_SBIT(LED1, SFR_P1, 5);                  // P1.5 LED1
SI_SBIT(LED2, SFR_P1, 6);                  // P1.6 LED2

#define SYSCLK          24500000       // SYSCLK frequency in Hz

#define SAMPLE_RATE_DAC 200000L        // DAC sampling rate in Hz

#define PHASE_PRECISION 65536          // Range of phase accumulator

#define FREQUENCY       1L        	   // Frequency of output in Hz

#define PHASE_ADD       (FREQUENCY * PHASE_PRECISION / SAMPLE_RATE_DAC)

// A full cycle, 12-bit, unsigned sine wave lookup table
SI_SEGMENT_VARIABLE(SINE_TABLE[256], uint16_t, const SI_SEG_CODE) =
{
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF,
		  0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
		  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
		  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
};

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN::TF2H (Timer # High Byte Overflow Flag)
// TMR3CN::TF2L (Timer # Low Byte Overflow Flag)
//
// This routine changes the state of the LED whenever Timer3 overflows.
//
//-----------------------------------------------------------------------------

SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{
   uint8_t SFRPAGE_save = SFRPAGE;

   static uint16_t phase_acc = 0;      // Holds phase accumulator

   SI_UU16_t temp;                     // The temporary value that holds
									   // value before being written
									   // to the IDAC

   SI_VARIABLE_SEGMENT_POINTER(table_ptr, uint16_t, const SI_SEG_CODE);  // Pointer to the lookup table


   TMR3CN0 &= ~0x80;                   // Clear Timer3 overflow flag

   table_ptr = SINE_TABLE;

   phase_acc += PHASE_ADD;             // Increment phase accumulator


   // Read the table value
   temp.u16 = *(table_ptr + (phase_acc >> 8));

   // Set the value of <temp> to the next output of DAC at full-scale
   // amplitude. The rails are 0x000 and 0xFFF. DAC low byte must be
   // written first.

   SFRPAGE = PG4_PAGE;

   DAC0L = temp.u8[LSB];
   DAC0H = temp.u8[MSB];

   DAC1L = temp.u8[LSB];
   DAC1H = temp.u8[MSB];

   SFRPAGE = SFRPAGE_save;

}

//-----------------------------------------------------------------------------
// Pin Declarations
//-----------------------------------------------------------------------------
SI_SBIT (LED_GREEN, SFR_P2, 4);           // green LED
SI_SBIT (LED_BLUE,  SFR_P2, 5);           // blue LED

//-----------------------------------------------------------------------------
// INT0_ISR
//-----------------------------------------------------------------------------
//
// INT0 ISR Content goes here. Remember to clear flag bits:
// TCON::IE0 (External Interrupt 0)
//
// Whenever a negative edge appears on P0.2, toggle LED_GREEN.
// The interrupt pending flag is automatically cleared by vectoring to the ISR
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (INT0_ISR, INT0_IRQn)
{
//STOPWATCH SEQUENCE
if(on == 0){
	//INSERT LED SEQUENCE HERE
	Timer3_Init(SYSCLK/SAMPLE_RATE_DAC);
}
if(on == 1){
	//STOP TIMER
	TMR3CN0 = 0x00;
}
}

//-----------------------------------------------------------------------------
// INT1_ISR
//-----------------------------------------------------------------------------
//
// INT1 ISR Content goes here. Remember to clear flag bits:
// TCON::IE1 (External Interrupt 1)
//
// Whenever a negative edge appears on P0.3, toggle LED_BLUE.
// The interrupt pending flag is automatically cleared by vectoring to the ISR
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (INT1_ISR, INT1_IRQn)
{
//LAP SEQUENCE
	if(P0_B5 == 0){
#define hourprime1 hour
#define minprime1 min
#define secprime1 sec
		P0_B5 = 1;
	}
	if(P0_B5 == 1){
#define hourprime2 hour
#define minprime2 min
#define secprime2 sec
		P0_B5 = 0;
	}
}


